import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Button
import csv
import pandas as pd
import random

# Load the time series from the CSV file generated by R
df = pd.read_csv("simulated_series.csv")

# Select a random column (excluding the "Time" column)
random_series = random.choice(df.columns[1:])
y_noisy = df[random_series].values  # Use the selected series for plotting
x = df["Time"].values  # Keep the original time values

# Calculate Prediction Interval (95% Confidence Level)
def calculate_prediction_interval(y, confidence_level=0.95):
    residuals = y - np.mean(y)
    std_dev = np.std(residuals)
    margin_of_error = 1.96 * std_dev
    y_upper = y + margin_of_error
    y_lower = y - margin_of_error
    return y_lower, y_upper

class InteractiveForecast:
    def __init__(self):
        self.fig, self.ax = plt.subplots(figsize=(8, 5))
        self.forecasts = []
        self.max_forecasts = 8
        self.forecast_x_positions = np.linspace(max(x) + 1, max(x) + 8, self.max_forecasts)

        # **Use the randomly selected R time series**
        self.x, self.y_noisy = x, y_noisy
        self.y_lower, self.y_upper = calculate_prediction_interval(self.y_noisy)

        # **Plot actual data points**
        self.ax.scatter(self.x, self.y_noisy, color='black', s=10, label=f"Observed Sales ({random_series})")

        # **Axis scaling**
        min_val = np.min(self.y_lower) - 20
        max_val = np.max(self.y_upper) + 20
        self.ax.set_xlim(0, max(self.forecast_x_positions) + 2)
        self.ax.set_ylim(min_val, max_val)

        # **Axis Labels**
        self.ax.set_xlabel("Time")
        self.ax.set_ylabel("Value")
        self.ax.legend()

        # **Initialize draggable forecast points**
        self.draggable_points = []
        self.forecast_lower, self.forecast_upper = calculate_prediction_interval(self.y_noisy[-8:])

        for i in range(len(self.forecast_x_positions)):
            x_pos = self.forecast_x_positions[i]
            lower_point, = self.ax.plot(x_pos, self.forecast_lower[i], 'ro', markersize=6, picker=True, label="Lower Bound (95%)" if i == 0 else "")
            upper_point, = self.ax.plot(x_pos, self.forecast_upper[i], 'go', markersize=6, picker=True, label="Upper Bound (95%)" if i == 0 else "")
            self.draggable_points.append((x_pos, lower_point, upper_point))

        # **Event Listeners**
        self.selected_point = None
        self.fig.canvas.mpl_connect('pick_event', self.on_pick)
        self.fig.canvas.mpl_connect('motion_notify_event', self.on_drag)
        self.fig.canvas.mpl_connect('button_release_event', self.on_release)

        # **Save Button**
        self.save_button_ax = plt.axes([0.8, 0.01, 0.1, 0.05])
        self.save_button = Button(self.save_button_ax, "Save")
        self.save_button.on_clicked(self.save_data)

    def on_pick(self, event):
        for x_pos, lower_point, upper_point in self.draggable_points:
            if event.artist == lower_point:
                self.selected_point = (x_pos, "lower", lower_point)
                break
            elif event.artist == upper_point:
                self.selected_point = (x_pos, "upper", upper_point)
                break

    def on_drag(self, event):
        if self.selected_point and event.inaxes == self.ax:
            x_pos, bound_type, point = self.selected_point
            point.set_ydata([event.ydata])
            self.fig.canvas.draw()

    def on_release(self, event):
        self.selected_point = None

    def save_data(self, event):
        forecast_results = []
        for x_pos, lower_point, upper_point in self.draggable_points:
            lower_y = lower_point.get_ydata()[0]
            upper_y = upper_point.get_ydata()[0]
            forecast_results.append((x_pos, lower_y, upper_y))

        with open('forecast_results.csv', mode='w', newline='') as file:
            writer = csv.writer(file)
            writer.writerow(["Period", "Lower Bound", "Upper Bound"])
            for result in forecast_results:
                writer.writerow(result)

        print("Saved Forecasts:", forecast_results)

    def show_plot(self):
        plt.show()

# **Run the Interactive Forecasting Tool**
interactive_forecast = InteractiveForecast()
interactive_forecast.show_plot()
