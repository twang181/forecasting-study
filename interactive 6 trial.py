import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Button
import pandas as pd  # To read the CSV file
import csv

# Read the time-series data from the CSV file generated by R
simulated_df = pd.read_csv('simulated_series_2.csv')

# Number of time series (columns) in the dataframe
n_series = simulated_df.shape[1] - 1  # Subtract 1 for the 'Time' column

# Class for interactive forecasting
class InteractiveForecast:
    def __init__(self):
        self.fig, self.ax = plt.subplots(figsize=(8, 5))
        self.forecasts = []
        self.max_forecasts = 4
        self.forecast_x_positions = np.linspace(49, 52, self.max_forecasts)

        # Initial random series selection
        self.series_counter = 0
        self.series_index = np.random.randint(1, n_series + 1)
        self.x = simulated_df['Time'].values  # Time values from the 'Time' column
        self.y_noisy = simulated_df[f"Series{self.series_index}"].values  # Select one of the simulated series

        # Set the title of the plot to display which series is being shown
        self.ax.set_title(f"Time Series: Series{self.series_index}")

        # **Plot actual noisy data points (black dots)**
        self.ax.scatter(self.x, self.y_noisy, color='black', s=10, label=f"Observed Sales (Series{self.series_index})")

        # **Adjust the formula to make the slope steeper**
        # Adjust the axis scaling to change how steep the plot looks
        self.ax.set_xlim(0, 53)  # X-axis limits (for time period)
        self.ax.set_ylim(min(self.y_noisy) - 5, max(self.y_noisy) + 5)  # Adjust Y-axis to fit the data better
        # Adjusting the y-axis manually based on the data
        self.ax.set_xlabel("Sales Period")
        self.ax.set_ylabel("Number of Sales")
        self.ax.set_yticks(np.arange(min(self.y_noisy) - 5, max(self.y_noisy) + 5, 5))  # Show y-axis ticks
        self.ax.set_xticks(np.arange(5, 53, 5))  # X-axis ticks every 5
        self.ax.set_xticklabels([str(i) for i in range(5, 55, 5)])  # Label X-axis
        self.ax.legend()

        # **Initialize draggable forecast points at 95% CL**
        self.draggable_points = []
        self.forecast_lower, self.forecast_upper = self.calculate_prediction_interval(self.y_noisy)

        # Create draggable points for forecast intervals
        self.lower_bound_points = []  # Store lower bound plot points
        self.upper_bound_points = []  # Store upper bound plot points
        for i in range(len(self.forecast_x_positions)):
            x_pos = self.forecast_x_positions[i]
            # Create lower bound point (red initially)
            lower_point, = self.ax.plot(x_pos, self.forecast_lower[i], 'ro', markersize=6, picker=True)
            # Create upper bound point (green initially)
            upper_point, = self.ax.plot(x_pos, self.forecast_upper[i], 'go', markersize=6, picker=True)

            self.draggable_points.append((x_pos, lower_point, upper_point))
            self.lower_bound_points.append(lower_point)  # Add to lower bound list
            self.upper_bound_points.append(upper_point)  # Add to upper bound list

        self.selected_point = None
        self.fig.canvas.mpl_connect('pick_event', self.on_pick)
        self.fig.canvas.mpl_connect('motion_notify_event', self.on_drag)
        self.fig.canvas.mpl_connect('button_release_event', self.on_release)

        self.save_button_ax = plt.axes([0.8, 0.01, 0.1, 0.05])
        self.save_button = Button(self.save_button_ax, "Save")
        self.save_button.on_clicked(self.save_data)

    def calculate_prediction_interval(self, y, confidence_level=0.95):
        residuals = y - np.mean(y)
        std_dev = np.std(residuals)
        margin_of_error = 1.96 * std_dev
        y_upper = y + margin_of_error
        y_lower = y - margin_of_error
        return y_lower, y_upper

    def on_pick(self, event):
        for x_pos, lower_point, upper_point in self.draggable_points:
            if event.artist == lower_point:
                self.selected_point = (x_pos, "lower", lower_point)
                break
            elif event.artist == upper_point:
                self.selected_point = (x_pos, "upper", upper_point)
                break

    def on_drag(self, event):
        if self.selected_point and event.inaxes == self.ax:
            x_pos, bound_type, point = self.selected_point
            point.set_ydata([event.ydata])

            # Dynamically update colors
            self.update_colors()

            self.fig.canvas.draw()

    def update_colors(self):
        for lower_point, upper_point in zip(self.lower_bound_points, self.upper_bound_points):
            lower_y = lower_point.get_ydata()[0]
            upper_y = upper_point.get_ydata()[0]

            # Ensure the lower bound is red and upper bound is green
            if lower_y > upper_y:
                lower_point.set_color('green')
                upper_point.set_color('red')
            else:
                lower_point.set_color('red')
                upper_point.set_color('green')

    def on_release(self, event):
        """Stops moving the point when mouse is released."""
        self.selected_point = None

    def save_data(self, event):
        """Saves forecast intervals in CSV format and switches to a new series."""
        forecast_results = []
        for x_pos, lower_point, upper_point in self.draggable_points:
            lower_y = lower_point.get_ydata()[0]
            upper_y = upper_point.get_ydata()[0]
            forecast_results.append((x_pos, lower_y, upper_y))

        # Save the results to a CSV file
        with open('forecast_results.csv', mode='a', newline='') as file:  # Append mode to add to the file
            writer = csv.writer(file)
            if file.tell() == 0:  # Write header only if file is empty
                writer.writerow(["Period", "Lower Bound", "Upper Bound"])  # Write header
            for result in forecast_results:
                writer.writerow(result)  # Write data

        print("Saved Forecasts:", forecast_results)  # You can also store this in a database

        # Switch to a new random time series after saving
        self.series_counter += 1
        print(self.series_counter)
        self.switch_to_new_series()

    def switch_to_new_series(self):
        """Switch to a new random time series."""
        # Clear the current plot
        self.ax.clear()

        # Select a new random series
        self.series_index = np.random.randint(1, n_series + 1)
        self.y_noisy = simulated_df[f"Series{self.series_index}"].values  # Select new series

        # Update the plot with the new time series
        self.ax.scatter(self.x, self.y_noisy, color='black', s=10, label=f"Observed Sales (Series{self.series_index})")
        self.ax.set_title(f"Time Series: Series{self.series_index}")

        # Recalculate the forecast intervals for the new series
        self.forecast_lower, self.forecast_upper = self.calculate_prediction_interval(self.y_noisy)

        # Clear and reinitialize forecast points
        self.draggable_points.clear()
        self.lower_bound_points.clear()
        self.upper_bound_points.clear()

        for i in range(len(self.forecast_x_positions)):
            x_pos = self.forecast_x_positions[i]
            # Create new lower bound point
            lower_point, = self.ax.plot(x_pos, self.forecast_lower[i], 'ro', markersize=6, picker=True)
            # Create new upper bound point
            upper_point, = self.ax.plot(x_pos, self.forecast_upper[i], 'go', markersize=6, picker=True)

            self.draggable_points.append((x_pos, lower_point, upper_point))
            self.lower_bound_points.append(lower_point)
            self.upper_bound_points.append(upper_point)

        # Redraw the updated plot
        self.ax.set_xlim(0, 53)
        self.ax.set_ylim(min(self.y_noisy) - 5, max(self.y_noisy) + 5)
        self.ax.set_xlabel("Sales Period")
        self.ax.set_ylabel("Number of Sales")
        self.ax.set_yticks(np.arange(min(self.y_noisy) - 5, max(self.y_noisy) + 5, 5))
        self.ax.set_xticks(np.arange(5, 53, 5))
        self.ax.set_xticklabels([str(i) for i in range(5, 55, 5)])
        self.ax.legend()

        self.fig.canvas.draw()

    def show_plot(self):
        plt.show()


# **Run the Interactive Forecasting Tool**
interactive_forecast = InteractiveForecast()
interactive_forecast.show_plot()
