import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Button
import pandas as pd  # To read the CSV file
import csv

# Read the time-series data from the CSV file generated by R
simulated_df = pd.read_csv('simulated_series_2.csv')

# Number of time series (columns) in the dataframe
n_series = simulated_df.shape[1] - 1  # Subtract 1 for the 'Time' column

# Experimental conditions
conditions = ["control", "80_point_interval", "95_point_interval", "80_interval", "95_interval"]

# Class for interactive forecasting
class InteractiveForecast:
    def __init__(self):
        self.fig, self.ax = plt.subplots(figsize=(8, 5))
        self.forecasts = []
        self.max_forecasts = 4
        self.forecast_x_positions = np.linspace(49, 52, self.max_forecasts)

        # Assign participant to a random condition
        self.condition = np.random.choice(conditions)
        print(f"Assigned Condition: {self.condition}")

        # Initial random series selection
        self.series_counter = 0
        self.series_index = np.random.randint(1, n_series + 1)
        self.x = simulated_df['Time'].values  # Time values from the 'Time' column
        self.y_noisy = simulated_df[f"Series{self.series_index}"].values  # Select one of the simulated series

        # Set the title of the plot to display which series is being shown
        self.ax.set_title(f"Time Series: Series{self.series_index}")

        # **Plot actual noisy data points (black dots)**
        self.ax.scatter(self.x, self.y_noisy, color='black', s=10, label=f"Observed Sales (Series{self.series_index})")

        # Adjust axis limits
        self.ax.set_xlim(0, 53)
        self.ax.set_ylim(min(self.y_noisy) - 5, max(self.y_noisy) + 5)
        self.ax.set_xlabel("Sales Period")
        self.ax.set_ylabel("Number of Sales")
        self.ax.set_yticks(np.arange(min(self.y_noisy) - 5, max(self.y_noisy) + 5, 5))
        self.ax.set_xticks(np.arange(5, 53, 5))
        self.ax.set_xticklabels([str(i) for i in range(5, 55, 5)])
        self.ax.legend()

        # Initialize forecast intervals if needed
        if self.condition == "control":
            self.user_intervals = {}  # Stores manually added intervals
            self.fig.canvas.mpl_connect('button_press_event', self.on_click)
        else:
            self.initialize_forecasts()

        self.selected_point = None
        self.fig.canvas.mpl_connect('pick_event', self.on_pick)
        self.fig.canvas.mpl_connect('motion_notify_event', self.on_drag)
        self.fig.canvas.mpl_connect('button_release_event', self.on_release)

        self.save_button_ax = plt.axes([0.8, 0.01, 0.1, 0.05])
        self.save_button = Button(self.save_button_ax, "Save")
        self.save_button.on_clicked(self.save_data)

    def initialize_forecasts(self):
        """Initialize forecast intervals based on assigned condition."""
        confidence_level = 0.95 if "95" in self.condition else 0.80
        self.forecast_lower, self.forecast_upper = self.calculate_prediction_interval(self.y_noisy, confidence_level)

        self.draggable_points = []
        self.lower_bound_points = []
        self.upper_bound_points = []

        for i, x_pos in enumerate(self.forecast_x_positions):
            lower_point, = self.ax.plot(x_pos, self.forecast_lower[i], 'ro', markersize=6, picker=True)
            upper_point, = self.ax.plot(x_pos, self.forecast_upper[i], 'go', markersize=6, picker=True)

            self.draggable_points.append((x_pos, lower_point, upper_point))
            self.lower_bound_points.append(lower_point)
            self.upper_bound_points.append(upper_point)

            # Display point forecasts if the condition includes them
            if "point" in self.condition:
                point_forecast = np.mean([self.forecast_lower[i], self.forecast_upper[i]])
                self.ax.plot(x_pos, point_forecast, 'bo', markersize=6, label="Point Forecast" if i == 0 else "")

    def calculate_prediction_interval(self, y, confidence_level=0.95):
        """Calculate prediction interval based on confidence level."""
        z_value = 1.96 if confidence_level == 0.95 else 1.28  # Approximate z-scores
        residuals = y - np.mean(y)
        std_dev = np.std(residuals)
        margin_of_error = z_value * std_dev
        y_upper = y + margin_of_error
        y_lower = y - margin_of_error
        return y_lower, y_upper

    def on_click(self, event):
        if self.condition != "control" or event.inaxes != self.ax:
            return

        x_pos = round(event.xdata)  # Round X-coordinate to match forecast periods
        y_pos = event.ydata  # Get Y-coordinate where user clicked

        # Ensure only valid forecast periods (49-52)
        if x_pos not in self.forecast_x_positions:
            return

        if x_pos in self.user_intervals:
            # If one bound exists, add/replace the second bound
            lower, upper = self.user_intervals[x_pos]
            if lower is None or (lower is not None and upper is not None):
                self.user_intervals[x_pos] = (y_pos, None)  # Reset and start new interval
            else:
                self.user_intervals[x_pos] = (lower, y_pos)
        else:
            self.user_intervals[x_pos] = (y_pos, None)

        self.update_manual_intervals()

    def update_manual_intervals(self):
        """Ensures each x-position has only one lower and one upper bound, replacing old ones before adding new ones."""

        # Step 1: Remove any old points for the clicked position
        for line in self.ax.get_lines()[:]:  # Loop over existing lines in the plot
            x_pos = line.get_xdata()[0]
            label = line.get_label()

            # Remove existing lower and upper bound points
            if label in ["Lower Bound", "Upper Bound"]:
                line.remove()

        # Step 2: Add the new points for the clicked position (one red for lower, one green for upper)
        for x_pos, (lower, upper) in self.user_intervals.items():
            if lower is not None and upper is not None:
                # Ensure the upper bound is always green and lower is red
                if lower > upper:
                    self.ax.plot(x_pos, lower, 'go', markersize=6, label="Lower Bound")
                    self.ax.plot(x_pos, upper, 'ro', markersize=6, label="Upper Bound")
                else:
                    self.ax.plot(x_pos, upper, 'go', markersize=6, label="Upper Bound")
                    self.ax.plot(x_pos, lower, 'ro', markersize=6, label="Lower Bound")
            elif lower is not None:
                self.ax.plot(x_pos, lower, 'ro', markersize=6, label="Lower Bound")
            elif upper is not None:
                self.ax.plot(x_pos, upper, 'go', markersize=6, label="Upper Bound")

        self.fig.canvas.draw()

    def on_pick(self, event):
        for x_pos, lower_point, upper_point in self.draggable_points:
            if event.artist == lower_point:
                self.selected_point = (x_pos, "lower", lower_point)
                break
            elif event.artist == upper_point:
                self.selected_point = (x_pos, "upper", upper_point)
                break

    def on_drag(self, event):
        if self.selected_point and event.inaxes == self.ax:
            x_pos, bound_type, point = self.selected_point
            point.set_ydata([event.ydata])

            # After dragging, update the colors so that the lower bound is red and the upper bound is green
            self.update_colors()

            self.fig.canvas.draw()

    def update_colors(self):
        # Loop through the bounds and update their colors based on their positions
        for lower_point, upper_point in zip(self.lower_bound_points, self.upper_bound_points):
            lower_y = lower_point.get_ydata()[0]
            upper_y = upper_point.get_ydata()[0]

            # If the lower y is greater than the upper y, swap their colors
            if lower_y > upper_y:
                lower_point.set_color('green')  # Lower bound is now green
                upper_point.set_color('red')  # Upper bound is now red
            else:
                lower_point.set_color('red')  # Lower bound is red
                upper_point.set_color('green')  # Upper bound is green

    def on_release(self, event):
        self.selected_point = None

    def save_data(self, event):
        """Saves forecast intervals in CSV format."""
        forecast_results = []

        if self.condition == "control":
            for x_pos, (lower, upper) in self.user_intervals.items():
                forecast_results.append((x_pos, lower, upper))
        else:
            for x_pos, lower_point, upper_point in self.draggable_points:
                lower_y = lower_point.get_ydata()[0]
                upper_y = upper_point.get_ydata()[0]
                forecast_results.append((x_pos, lower_y, upper_y))

        with open('forecast_results.csv', mode='a', newline='') as file:
            writer = csv.writer(file)
            if file.tell() == 0:
                writer.writerow(["Period", "Lower Bound", "Upper Bound", "Condition"])
            for result in forecast_results:
                writer.writerow([*result, self.condition])

        print("Saved Forecasts:", forecast_results)

        self.series_counter += 1
        print(self.series_counter)
        self.switch_to_new_series()

    def switch_to_new_series(self):
        """Switch to a new random time series."""
        self.ax.clear()  # Clear the current plot

        # Clear the user intervals for the control condition to reset the plot
        if self.condition == "control":
            self.user_intervals = {}

        # Randomly select a new series index
        self.series_index = np.random.randint(1, n_series + 1)
        self.y_noisy = simulated_df[f"Series{self.series_index}"].values

        # Plot the new time series
        self.ax.scatter(self.x, self.y_noisy, color='black', s=10, label=f"Observed Sales (Series{self.series_index})")
        self.ax.set_title(f"Time Series: Series{self.series_index}")

        # Re-initialize forecast intervals if the condition isn't "control"
        if self.condition != "control":
            self.initialize_forecasts()

        # Set plot limits and labels
        self.ax.set_xlim(0, 53)
        self.ax.set_ylim(min(self.y_noisy) - 5, max(self.y_noisy) + 5)
        self.ax.set_xlabel("Sales Period")
        self.ax.set_ylabel("Number of Sales")
        self.ax.set_yticks(np.arange(min(self.y_noisy) - 5, max(self.y_noisy) + 5, 5))
        self.ax.set_xticks(np.arange(5, 53, 5))
        self.ax.set_xticklabels([str(i) for i in range(5, 55, 5)])
        self.ax.legend()

        # Redraw the canvas
        self.fig.canvas.draw()

    def show_plot(self):
        plt.show()


# **Run the Interactive Forecasting Tool**
interactive_forecast = InteractiveForecast()
interactive_forecast.show_plot()
