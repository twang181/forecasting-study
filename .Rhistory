trend_component <- rep(0, n)
}
# Sine wave seasonality component
if (seasonality == "S") {  # Multiplicative seasonality via sine wave
seasonal_component <- sin(2 * pi * time / 4) * 0.1 + 1
} else {  # No seasonality
seasonal_component <- rep(1, n)
}
# Noise
noise_sd <- ifelse(noise_level == "Low", 4, 8) #low: 2, high: 8 #this is gaussian noise
noise <- rnorm(n, mean = 0, sd = noise_sd)
# Multiplicative seasonality model
y <- (level + trend_component) * seasonal_component + noise
#y <- level + trend_component + seasonal_component + noise #additive
return(data.frame(time, y))
}
# Define ETS Model Selection Function
select_ets_model <- function(trend, seasonality) {
if (trend == "NT" & seasonality == "NS") return("ANN")  # Additive error, No Trend, No Seasonality
if (trend == "NT" & seasonality == "S") return("MNM")  # Multiplicative error, No Trend, Multiplicative Seasonality
if (trend == "UT" & seasonality == "NS") return("AAN")  # Additive error, Additive Trend, No Seasonality
if (trend == "UT" & seasonality == "S") return("MAM")  # Multiplicative error, Additive Trend, Multiplicative Seasonality
if (trend == "DT" & seasonality == "NS") return("AAN")  # Additive error, Additive Trend, No Seasonality
if (trend == "DT" & seasonality == "S") return("MAM")  # Multiplicative error, Additive Trend, Multiplicative Seasonality
return("ANN")  # Default fallback
}
# Forecast Function
forecast_series <- function(df, model_type, h=4) {
ts_data <- ts(df$y, frequency=4)  # Quarterly data
model <- ets(ts_data, model=model_type)
forecasted <- forecast(model, h=h, level=c(80, 95))
return(data.frame(
time = max(df$time) + 1:h,
y = forecasted$mean,
lower_80 = forecasted$lower[,1],
upper_80 = forecasted$upper[,1],
lower_95 = forecasted$lower[,2],
upper_95 = forecasted$upper[,2]
))
}
# Parameter grid
trends <- c("NT", "UT", "DT")
seasonalities <- c("NS", "S")
noise_levels <- c("Low", "High")
plots <- list()
plot_num <- 1
for (noise in noise_levels) {
for (trend in trends) {
for (seasonality in seasonalities) {
for (replication in 1:2) {  # Two samples per setting
df <- generate_series(trend, seasonality, noise)
model_type <- select_ets_model(trend, seasonality)
forecast_df <- forecast_series(df, model_type, h=4)
all_y_values <- c(all_y_values, df$y, forecast_df$y, forecast_df$lower_95, forecast_df$upper_95)
p <- ggplot(df, aes(x=time, y=y)) +
geom_line() + geom_point(data=forecast_df, aes(x=time, y=y), color="blue", size=2) +
geom_ribbon(data=forecast_df, aes(x=time, ymin=lower_80, ymax=upper_80), fill="blue", alpha=0.2) +
geom_ribbon(data=forecast_df, aes(x=time, ymin=lower_95, ymax=upper_95), fill="red", alpha=0.2) +
ggtitle(paste(noise, "Noise |", trend, "|", ifelse(seasonality == "S", "Mul. Seas.", "No Seas."))) +
theme_minimal() +
theme(plot.title = element_text(size=8))
plots[[plot_num]] <- p
plot_num <- plot_num + 1
}
}
}
}
# Arrange plots in a grid
grid.arrange(grobs = plots, ncol=4)
library(ggplot2)
library(gridExtra)
library(forecast)
set.seed(123)
generate_series <- function(trend, seasonality, noise_level, n=52) {
time <- 1:n
level <- 100
# Trend component
if (trend == "UT") {  # Upward trend
trend_component <- 0.5 * time
} else if (trend == "DT") {  # Downward trend
trend_component <- -0.5 * time
} else {  # No trend
trend_component <- rep(0, n)
}
# Sine wave seasonality component
if (seasonality == "S") {  # Multiplicative seasonality via sine wave
seasonal_component <- sin(2 * pi * time / 4) * 0.1 + 1
} else {  # No seasonality
seasonal_component <- rep(1, n)
}
# Noise
noise_sd <- ifelse(noise_level == "Low", 4, 8) #low: 2, high: 8 #this is gaussian noise
noise <- rnorm(n, mean = 0, sd = noise_sd)
# Multiplicative seasonality model
y <- (level + trend_component) * seasonal_component + noise
#y <- level + trend_component + seasonal_component + noise #additive
return(data.frame(time, y))
}
# Define ETS Model Selection Function
select_ets_model <- function(trend, seasonality) {
if (trend == "NT" & seasonality == "NS") return("ANN")  # Additive error, No Trend, No Seasonality
if (trend == "NT" & seasonality == "S") return("MNM")  # Multiplicative error, No Trend, Multiplicative Seasonality
if (trend == "UT" & seasonality == "NS") return("AAN")  # Additive error, Additive Trend, No Seasonality
if (trend == "UT" & seasonality == "S") return("MAM")  # Multiplicative error, Additive Trend, Multiplicative Seasonality
if (trend == "DT" & seasonality == "NS") return("AAN")  # Additive error, Additive Trend, No Seasonality
if (trend == "DT" & seasonality == "S") return("MAM")  # Multiplicative error, Additive Trend, Multiplicative Seasonality
return("ANN")  # Default fallback
}
# Forecast Function
forecast_series <- function(df, model_type, h=4) {
ts_data <- ts(df$y, frequency=4)  # Quarterly data
model <- ets(ts_data, model=model_type)
forecasted <- forecast(model, h=h, level=c(80, 95))
return(data.frame(
time = max(df$time) + 1:h,
y = forecasted$mean,
lower_80 = forecasted$lower[,1],
upper_80 = forecasted$upper[,1],
lower_95 = forecasted$lower[,2],
upper_95 = forecasted$upper[,2]
))
}
# Parameter grid
trends <- c("NT", "UT", "DT")
seasonalities <- c("NS", "S")
noise_levels <- c("Low", "High")
plots <- list()
plot_num <- 1
point_table <- data.frame()
ci_table <- data.frame()
for (noise in noise_levels) {
for (trend in trends) {
for (seasonality in seasonalities) {
for (replication in 1:2) {  # Two samples per setting
df <- generate_series(trend, seasonality, noise)
model_type <- select_ets_model(trend, seasonality)
forecast_df <- forecast_series(df, model_type, h=4)
# Combine actual and forecasted values
df_combined <- rbind(
data.frame(time = df$time, y = df$y, type = "Actual"),
data.frame(time = forecast_df$time, y = forecast_df$y, type = "Forecast")
)
df_combined$trend <- trend
df_combined$seasonality <- seasonality
df_combined$noise <- noise
df_combined$replication <- replication
point_table <- rbind(point_table, df_combined)
# Save confidence intervals
ci_df <- data.frame(
time = forecast_df$time,
lower_80 = forecast_df$lower_80,
upper_80 = forecast_df$upper_80,
lower_95 = forecast_df$lower_95,
upper_95 = forecast_df$upper_95,
trend = trend,
seasonality = seasonality,
noise = noise,
replication = replication
)
ci_table <- rbind(ci_table, ci_df)
all_y_values <- c(all_y_values, df$y, forecast_df$y, forecast_df$lower_95, forecast_df$upper_95)
p <- ggplot(df, aes(x=time, y=y)) +
geom_line() + geom_point(data=forecast_df, aes(x=time, y=y), color="blue", size=2) +
geom_ribbon(data=forecast_df, aes(x=time, ymin=lower_80, ymax=upper_80), fill="blue", alpha=0.2) +
geom_ribbon(data=forecast_df, aes(x=time, ymin=lower_95, ymax=upper_95), fill="red", alpha=0.2) +
ggtitle(paste(noise, "Noise |", trend, "|", ifelse(seasonality == "S", "Mul. Seas.", "No Seas."))) +
theme_minimal() +
theme(plot.title = element_text(size=8))
plots[[plot_num]] <- p
plot_num <- plot_num + 1
}
}
}
}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(gridExtra)
library(forecast)
set.seed(123)
generate_series <- function(trend, seasonality, noise_level, n=52) {
time <- 1:n
level <- 100
# Trend component
if (trend == "UT") {  # Upward trend
trend_component <- 0.5 * time
} else if (trend == "DT") {  # Downward trend
trend_component <- -0.5 * time
} else {  # No trend
trend_component <- rep(0, n)
}
# Sine wave seasonality component
if (seasonality == "S") {  # Multiplicative seasonality via sine wave
seasonal_component <- sin(2 * pi * time / 4) * 0.1 + 1
} else {  # No seasonality
seasonal_component <- rep(1, n)
}
# Noise
noise_sd <- ifelse(noise_level == "Low", 4, 8) #low: 2, high: 8 #this is gaussian noise
noise <- rnorm(n, mean = 0, sd = noise_sd)
# Multiplicative seasonality model
y <- (level + trend_component) * seasonal_component + noise
#y <- level + trend_component + seasonal_component + noise #additive
return(data.frame(time, y))
}
# Define ETS Model Selection Function
select_ets_model <- function(trend, seasonality) {
if (trend == "NT" & seasonality == "NS") return("ANN")  # Additive error, No Trend, No Seasonality
if (trend == "NT" & seasonality == "S") return("MNM")  # Multiplicative error, No Trend, Multiplicative Seasonality
if (trend == "UT" & seasonality == "NS") return("AAN")  # Additive error, Additive Trend, No Seasonality
if (trend == "UT" & seasonality == "S") return("MAM")  # Multiplicative error, Additive Trend, Multiplicative Seasonality
if (trend == "DT" & seasonality == "NS") return("AAN")  # Additive error, Additive Trend, No Seasonality
if (trend == "DT" & seasonality == "S") return("MAM")  # Multiplicative error, Additive Trend, Multiplicative Seasonality
return("ANN")  # Default fallback
}
# Forecast Function
forecast_series <- function(df, model_type, h=4) {
ts_data <- ts(df$y, frequency=4)  # Quarterly data
model <- ets(ts_data, model=model_type)
forecasted <- forecast(model, h=h, level=c(80, 95))
mean_vals <- as.numeric(forecasted$mean)
lower_80_vals <- as.numeric(forecasted$lower[, 1])
upper_80_vals <- as.numeric(forecasted$upper[, 1])
lower_95_vals <- as.numeric(forecasted$lower[, 2])
upper_95_vals <- as.numeric(forecasted$upper[, 2])
return(data.frame(
time = max(df$time) + 1:h,
y = forecasted$mean,
lower_80 = forecasted$lower[,1],
upper_80 = forecasted$upper[,1],
lower_95 = forecasted$lower[,2],
upper_95 = forecasted$upper[,2]
))
}
# Parameter grid
trends <- c("NT", "UT", "DT")
seasonalities <- c("NS", "S")
noise_levels <- c("Low", "High")
plots <- list()
plot_num <- 1
point_table <- data.frame()
ci_table <- data.frame()
for (noise in noise_levels) {
for (trend in trends) {
for (seasonality in seasonalities) {
for (replication in 1:2) {  # Two samples per setting
df <- generate_series(trend, seasonality, noise)
model_type <- select_ets_model(trend, seasonality)
forecast_df <- forecast_series(df, model_type, h=4)
# Combine actual and forecasted values
df_combined <- rbind(
data.frame(time = df$time, y = df$y, type = "Actual"),
data.frame(time = forecast_df$time, y = forecast_df$y, type = "Forecast")
)
df_combined$trend <- trend
df_combined$seasonality <- seasonality
df_combined$noise <- noise
df_combined$replication <- replication
point_table <- rbind(point_table, df_combined)
# Save confidence intervals
ci_df <- data.frame(
time = forecast_df$time,
lower_80 = forecast_df$lower_80,
upper_80 = forecast_df$upper_80,
lower_95 = forecast_df$lower_95,
upper_95 = forecast_df$upper_95,
trend = trend,
seasonality = seasonality,
noise = noise,
replication = replication
)
ci_table <- rbind(ci_table, ci_df)
all_y_values <- c(all_y_values, df$y, forecast_df$y, forecast_df$lower_95, forecast_df$upper_95)
p <- ggplot(df, aes(x=time, y=y)) +
geom_line() + geom_point(data=forecast_df, aes(x=time, y=y), color="blue", size=2) +
geom_ribbon(data=forecast_df, aes(x=time, ymin=lower_80, ymax=upper_80), fill="blue", alpha=0.2) +
geom_ribbon(data=forecast_df, aes(x=time, ymin=lower_95, ymax=upper_95), fill="red", alpha=0.2) +
ggtitle(paste(noise, "Noise |", trend, "|", ifelse(seasonality == "S", "Mul. Seas.", "No Seas."))) +
theme_minimal() +
theme(plot.title = element_text(size=8))
plots[[plot_num]] <- p
plot_num <- plot_num + 1
}
}
}
}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(gridExtra)
library(forecast)
set.seed(123)
generate_series <- function(trend, seasonality, noise_level, n=52) {
time <- 1:n
level <- 100
# Trend component
if (trend == "UT") {  # Upward trend
trend_component <- 0.5 * time
} else if (trend == "DT") {  # Downward trend
trend_component <- -0.5 * time
} else {  # No trend
trend_component <- rep(0, n)
}
# Sine wave seasonality component
if (seasonality == "S") {  # Multiplicative seasonality via sine wave
seasonal_component <- sin(2 * pi * time / 4) * 0.1 + 1
} else {  # No seasonality
seasonal_component <- rep(1, n)
}
# Noise
noise_sd <- ifelse(noise_level == "Low", 4, 8) #low: 2, high: 8 #this is gaussian noise
noise <- rnorm(n, mean = 0, sd = noise_sd)
# Multiplicative seasonality model
y <- (level + trend_component) * seasonal_component + noise
#y <- level + trend_component + seasonal_component + noise #additive
return(data.frame(time, y))
}
# Define ETS Model Selection Function
select_ets_model <- function(trend, seasonality) {
if (trend == "NT" & seasonality == "NS") return("ANN")  # Additive error, No Trend, No Seasonality
if (trend == "NT" & seasonality == "S") return("MNM")  # Multiplicative error, No Trend, Multiplicative Seasonality
if (trend == "UT" & seasonality == "NS") return("AAN")  # Additive error, Additive Trend, No Seasonality
if (trend == "UT" & seasonality == "S") return("MAM")  # Multiplicative error, Additive Trend, Multiplicative Seasonality
if (trend == "DT" & seasonality == "NS") return("AAN")  # Additive error, Additive Trend, No Seasonality
if (trend == "DT" & seasonality == "S") return("MAM")  # Multiplicative error, Additive Trend, Multiplicative Seasonality
return("ANN")  # Default fallback
}
# Forecast Function
forecast_series <- function(df, model_type, h=4) {
ts_data <- ts(df$y, frequency=4)  # Quarterly data
model <- ets(ts_data, model=model_type)
forecasted <- forecast(model, h=h, level=c(80, 95))
mean_vals <- as.numeric(forecasted$mean)
lower_80_vals <- as.numeric(forecasted$lower[, 1])
upper_80_vals <- as.numeric(forecasted$upper[, 1])
lower_95_vals <- as.numeric(forecasted$lower[, 2])
upper_95_vals <- as.numeric(forecasted$upper[, 2])
return(data.frame(
time = max(df$time) + 1:h,
y = forecasted$mean,
lower_80 = forecasted$lower[,1],
upper_80 = forecasted$upper[,1],
lower_95 = forecasted$lower[,2],
upper_95 = forecasted$upper[,2]
))
}
# Parameter grid
trends <- c("NT", "UT", "DT")
seasonalities <- c("NS", "S")
noise_levels <- c("Low", "High")
plots <- list()
plot_num <- 1
point_table <- data.frame(time = numeric(),
y = numeric(),
type = character(),
trend = character(),
seasonality = character(),
noise = character(),
replication = numeric(),
stringsAsFactors = FALSE)
ci_table <- data.frame(time = numeric(),
lower_80 = numeric(),
upper_80 = numeric(),
lower_95 = numeric(),
upper_95 = numeric(),
trend = character(),
seasonality = character(),
noise = character(),
replication = numeric(),
stringsAsFactors = FALSE)
for (noise in noise_levels) {
for (trend in trends) {
for (seasonality in seasonalities) {
for (replication in 1:2) {  # Two samples per setting
df <- generate_series(trend, seasonality, noise)
model_type <- select_ets_model(trend, seasonality)
forecast_df <- forecast_series(df, model_type, h=4)
# Combine actual and forecasted values
df_combined <- rbind(
data.frame(time = df$time, y = df$y, type = "Actual"),
data.frame(time = forecast_df$time, y = forecast_df$y, type = "Forecast")
)
df_combined$trend <- trend
df_combined$seasonality <- seasonality
df_combined$noise <- noise
df_combined$replication <- replication
point_table <- rbind(point_table, df_combined)
# Save confidence intervals
ci_df <- data.frame(
time = forecast_df$time,
lower_80 = forecast_df$lower_80,
upper_80 = forecast_df$upper_80,
lower_95 = forecast_df$lower_95,
upper_95 = forecast_df$upper_95,
trend = trend,
seasonality = seasonality,
noise = noise,
replication = replication
)
ci_table <- rbind(ci_table, ci_df)
all_y_values <- c(all_y_values, df$y, forecast_df$y, forecast_df$lower_95, forecast_df$upper_95)
p <- ggplot(df, aes(x=time, y=y)) +
geom_line() + geom_point(data=forecast_df, aes(x=time, y=y), color="blue", size=2) +
geom_ribbon(data=forecast_df, aes(x=time, ymin=lower_80, ymax=upper_80), fill="blue", alpha=0.2) +
geom_ribbon(data=forecast_df, aes(x=time, ymin=lower_95, ymax=upper_95), fill="red", alpha=0.2) +
ggtitle(paste(noise, "Noise |", trend, "|", ifelse(seasonality == "S", "Mul. Seas.", "No Seas."))) +
theme_minimal() +
theme(plot.title = element_text(size=8))
plots[[plot_num]] <- p
plot_num <- plot_num + 1
}
}
}
}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(gridExtra)
library(forecast)
set.seed(123)
generate_series <- function(trend, seasonality, noise_level, n=52) {
time <- 1:n
level <- 100
# Trend component
if (trend == "UT") {  # Upward trend
trend_component <- 0.5 * time
} else if (trend == "DT") {  # Downward trend
trend_component <- -0.5 * time
} else {  # No trend
trend_component <- rep(0, n)
}
# Sine wave seasonality component
if (seasonality == "S") {  # Multiplicative seasonality via sine wave
seasonal_component <- sin(2 * pi * time / 4) * 0.1 + 1
} else {  # No seasonality
seasonal_component <- rep(1, n)
}
# Noise
noise_sd <- ifelse(noise_level == "Low", 4, 8) #low: 2, high: 8 #this is gaussian noise
noise <- rnorm(n, mean = 0, sd = noise_sd)
# Multiplicative seasonality model
y <- (level + trend_component) * seasonal_component + noise
#y <- level + trend_component + seasonal_component + noise #additive
return(data.frame(time, y))
}
# Define ETS Model Selection Function
select_ets_model <- function(trend, seasonality) {
if (trend == "NT" & seasonality == "NS") return("ANN")  # Additive error, No Trend, No Seasonality
if (trend == "NT" & seasonality == "S") return("MNM")  # Multiplicative error, No Trend, Multiplicative Seasonality
if (trend == "UT" & seasonality == "NS") return("AAN")  # Additive error, Additive Trend, No Seasonality
if (trend == "UT" & seasonality == "S") return("MAM")  # Multiplicative error, Additive Trend, Multiplicative Seasonality
if (trend == "DT" & seasonality == "NS") return("AAN")  # Additive error, Additive Trend, No Seasonality
if (trend == "DT" & seasonality == "S") return("MAM")  # Multiplicative error, Additive Trend, Multiplicative Seasonality
return("ANN")  # Default fallback
}
# Forecast Function
forecast_series <- function(df, model_type, h=4) {
ts_data <- ts(df$y, frequency=4)  # Quarterly data
model <- ets(ts_data, model=model_type)
forecasted <- forecast(model, h=h, level=c(80, 95))
mean_vals <- as.numeric(forecasted$mean)
lower_80_vals <- as.numeric(forecasted$lower[, 1])
upper_80_vals <- as.numeric(forecasted$upper[, 1])
lower_95_vals <- as.numeric(forecasted$lower[, 2])
upper_95_vals <- as.numeric(forecasted$upper[, 2])
return(data.frame(
time = max(df$time) + 1:h,
y = mean_vals,
lower_80 = lower_80_vals,
upper_80 = upper_80_vals,
lower_95 = lower_95_vals,
upper_95 = upper_95_vals
))
}
# Parameter grid
trends <- c("NT", "UT", "DT")
seasonalities <- c("NS", "S")
noise_levels <- c("Low", "High")
plots <- list()
plot_num <- 1
for (noise in noise_levels) {
for (trend in trends) {
for (seasonality in seasonalities) {
for (replication in 1:2) {  # Two samples per setting
df <- generate_series(trend, seasonality, noise)
model_type <- select_ets_model(trend, seasonality)
forecast_df <- forecast_series(df, model_type, h=4)
# Combine actual and forecasted values
df_combined <- rbind(
data.frame(time = df$time, y = df$y, type = "Actual"),
data.frame(time = forecast_df$time, y = forecast_df$y, type = "Forecast")
)
all_y_values <- c(all_y_values, df$y, forecast_df$y, forecast_df$lower_95, forecast_df$upper_95)
p <- ggplot(df, aes(x=time, y=y)) +
geom_line() + geom_point(data=forecast_df, aes(x=time, y=y), color="blue", size=2) +
geom_ribbon(data=forecast_df, aes(x=time, ymin=lower_80, ymax=upper_80), fill="blue", alpha=0.2) +
geom_ribbon(data=forecast_df, aes(x=time, ymin=lower_95, ymax=upper_95), fill="red", alpha=0.2) +
ggtitle(paste(noise, "Noise |", trend, "|", ifelse(seasonality == "S", "Mul. Seas.", "No Seas."))) +
theme_minimal() +
theme(plot.title = element_text(size=8))
plots[[plot_num]] <- p
plot_num <- plot_num + 1
}
}
}
}
# Arrange plots in a grid
grid.arrange(grobs = plots, ncol=4)
write.csv(forecasted_df, file = paste0("forecast_series_", series_id, ".csv"), row.names = FALSE)
View(ci_df)
View(point_table)
View(df_combined)
View(point_table)
View(ci_table)
View(ci_df)
