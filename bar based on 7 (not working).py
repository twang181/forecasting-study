import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Button
import pandas as pd
import csv

# Read the time-series data from the CSV file generated by R
simulated_df = pd.read_csv('simulated_series_2.csv')

# Load full series of 52 points
series = pd.read_csv("series_1.csv")["y"]

history = series.iloc[:48]  # shown to participants
true_future = series.iloc[48:52]  # used for scoring forecasts


# Number of time series (columns) in the dataframe
n_series = simulated_df.shape[1] - 1  # Subtract 1 for the 'Time' column

# Experimental conditions
conditions = ["control", "80_point_interval", "95_point_interval", "80_interval", "95_interval"]

# Class for interactive forecasting
class InteractiveForecast:
    def __init__(self):
        self.fig, self.ax = plt.subplots(figsize=(8, 5))
        self.forecasts = []
        self.max_forecasts = 4
        self.forecast_x_positions = np.linspace(49, 52, self.max_forecasts)

        # Assign participant to a random condition
        self.condition = np.random.choice(conditions)
        print(f"Assigned Condition: {self.condition}")

        # Initial random series selection
        self.series_counter = 0
        self.series_index = np.random.randint(1, n_series + 1)
        self.x = simulated_df['Time'].values  # Time values from the 'Time' column
        self.y_noisy = simulated_df[f"Series{self.series_index}"].values  # Select one of the simulated series

        # Set the title of the plot to display which series is being shown
        self.ax.set_title(f"Time Series: Series{self.series_index}")

        # **Plot actual noisy data points (black dots)**
        self.ax.scatter(self.x, self.y_noisy, color='black', s=10, label=f"Observed Sales (Series{self.series_index})")

        # Adjust axis limits
        self.ax.set_xlim(0, 53)
        self.ax.set_ylim(min(self.y_noisy) - 5, max(self.y_noisy) + 5)
        self.ax.set_xlabel("Sales Period")
        self.ax.set_ylabel("Number of Sales")
        self.ax.set_yticks(np.arange(min(self.y_noisy) - 5, max(self.y_noisy) + 5, 5))
        self.ax.set_xticks(np.arange(5, 53, 5))
        self.ax.set_xticklabels([str(i) for i in range(5, 55, 5)])
        self.ax.legend()

        # Initialize forecast intervals if needed
        if self.condition == "control":
            self.user_intervals = {}  # Stores manually added intervals
            self.fig.canvas.mpl_connect('button_press_event', self.on_click)
        else:
            self.initialize_forecasts()

        self.selected_point = None
        self.fig.canvas.mpl_connect('pick_event', self.on_pick)
        self.fig.canvas.mpl_connect('motion_notify_event', self.on_drag)
        self.fig.canvas.mpl_connect('button_release_event', self.on_release)

        self.save_button_ax = plt.axes([0.8, 0.01, 0.1, 0.05])
        self.save_button = Button(self.save_button_ax, "Save")
        self.save_button.on_clicked(self.save_data)

    def initialize_forecasts(self):
        """Initialize bars + draggable handles for forecast intervals."""
        confidence_level = 0.95 if "95" in self.condition else 0.80
        self.forecast_lower, self.forecast_upper = self.calculate_prediction_interval(self.y_noisy, confidence_level)

        self.bars = []
        self.lower_handles = []
        self.upper_handles = []

        bar_width = 0.5

        for i, x_pos in enumerate(self.forecast_x_positions):
            lower = self.forecast_lower[i]
            upper = self.forecast_upper[i]
            height = upper - lower

            # Create the bar
            bar = self.ax.bar(x_pos, height, bottom=lower, width=bar_width, color='skyblue', edgecolor='black')[0]
            self.bars.append((x_pos, bar))

            # Add lower and upper draggable points (handles)
            lower_handle, = self.ax.plot(x_pos, lower, 'ro', markersize=8, picker=True)
            upper_handle, = self.ax.plot(x_pos, upper, 'go', markersize=8, picker=True)

            self.lower_handles.append((x_pos, lower_handle))
            self.upper_handles.append((x_pos, upper_handle))

            if "point" in self.condition:
                point_forecast = np.mean([lower, upper])
                self.ax.plot(x_pos, point_forecast, 'bo', markersize=6, label="Point Forecast" if i == 0 else "")

    def calculate_prediction_interval(self, y, confidence_level=0.95):
        """Calculate prediction interval based on confidence level."""
        z_value = 1.96 if confidence_level == 0.95 else 1.28  # Approximate z-scores
        residuals = y - np.mean(y)
        std_dev = np.std(residuals)
        margin_of_error = z_value * std_dev
        y_upper = y + margin_of_error
        y_lower = y - margin_of_error
        return y_lower, y_upper

    def on_click(self, event):
        if self.condition != "control" or event.inaxes != self.ax:
            return

        x_pos = round(event.xdata)
        y_pos = event.ydata

        # Only allow clicks in forecast periods
        if x_pos not in self.forecast_x_positions:
            return

        # Initialize if not yet set
        if x_pos not in self.user_intervals:
            self.user_intervals[x_pos] = [None, None, None]  # lower, upper, bar handle

        lower, upper, _ = self.user_intervals[x_pos]

        if lower is None:
            self.user_intervals[x_pos][0] = y_pos  # Set lower
        elif upper is None:
            self.user_intervals[x_pos][1] = y_pos  # Set upper
        else:
            # Both lower & upper already exist, replace closest one
            if abs(y_pos - lower) < abs(y_pos - upper):
                self.user_intervals[x_pos][0] = y_pos  # Update lower
            else:
                self.user_intervals[x_pos][1] = y_pos  # Update upper

        self.add_bar(x_pos)

    def add_bar(self, x_pos):
        lower, upper, bar = self.user_intervals[x_pos]

        # Only add bar if both bounds exist
        if lower is None or upper is None:
            return

        # Ensure lower is below upper
        if lower > upper:
            lower, upper = upper, lower
            self.user_intervals[x_pos][0] = lower
            self.user_intervals[x_pos][1] = upper

        # If a bar already exists, remove it before adding a new one
        if bar:
            bar.remove()

        bar = self.ax.bar(x_pos, upper - lower, bottom=lower, width=0.5, color='skyblue', edgecolor='black', alpha=0.4)[0]
        self.user_intervals[x_pos][2] = bar
        self.fig.canvas.draw()

    def update_manual_intervals(self):
        """Ensures each x-position has only one lower and one upper bound, replacing old ones before adding new ones."""

        # Step 1: Remove any old points for the clicked position
        for line in self.ax.get_lines()[:]:  # Loop over existing lines in the plot
            x_pos = line.get_xdata()[0]
            label = line.get_label()

            # Remove existing lower and upper bound points
            if label in ["Lower Bound", "Upper Bound"]:
                line.remove()

        # Step 2: Add the new points for the clicked position (one red for lower, one green for upper)
        for x_pos, (lower, upper) in self.user_intervals.items():
            if lower is not None and upper is not None:
                # Ensure the upper bound is always green and lower is red
                if lower > upper:
                    self.ax.plot(x_pos, lower, 'go', markersize=6, label="Lower Bound")
                    self.ax.plot(x_pos, upper, 'ro', markersize=6, label="Upper Bound")
                else:
                    self.ax.plot(x_pos, upper, 'go', markersize=6, label="Upper Bound")
                    self.ax.plot(x_pos, lower, 'ro', markersize=6, label="Lower Bound")
            elif lower is not None:
                self.ax.plot(x_pos, lower, 'ro', markersize=6, label="Lower Bound")
            elif upper is not None:
                self.ax.plot(x_pos, upper, 'go', markersize=6, label="Upper Bound")

        self.fig.canvas.draw()

    def on_pick(self, event):
        for x_pos, handle in self.lower_handles:
            if event.artist == handle:
                self.selected_point = (x_pos, "lower", handle)
                return
        for x_pos, handle in self.upper_handles:
            if event.artist == handle:
                self.selected_point = (x_pos, "upper", handle)
                return

    def on_drag(self, event):
        if self.selected_point and event.inaxes == self.ax:
            x_pos, bound_type, handle = self.selected_point

            # Drag handle
            handle.set_ydata([event.ydata])

            # Find the corresponding bar
            for idx, (bar_x, bar) in enumerate(self.bars):
                if bar_x == x_pos:
                    lower_y = self.lower_handles[idx][1].get_ydata()[0]
                    upper_y = self.upper_handles[idx][1].get_ydata()[0]

                    # Ensure lower < upper
                    if lower_y > upper_y:
                        lower_y, upper_y = upper_y, lower_y
                        self.lower_handles[idx][1].set_ydata([lower_y])
                        self.upper_handles[idx][1].set_ydata([upper_y])

                    # Update bar's position and height
                    bar.set_y(lower_y)
                    bar.set_height(upper_y - lower_y)
                    break

            self.fig.canvas.draw()

    def on_release(self, event):
        self.selected_point = None

    def save_data(self, event):
        forecast_results = []

        if self.condition == "control":
            for x_pos, (lower, upper) in self.user_intervals.items():
                forecast_results.append((x_pos, lower, upper))
        else:
            for x_pos, bar in self.bars:
                lower = bar.get_y()
                upper = bar.get_y() + bar.get_height()
                forecast_results.append((x_pos, lower, upper))

        with open('forecast_results.csv', mode='a', newline='') as file:
            writer = csv.writer(file)
            if file.tell() == 0:
                writer.writerow(["Period", "Lower Bound", "Upper Bound", "Condition"])
            for result in forecast_results:
                writer.writerow([*result, self.condition])

        print("Saved Forecasts:", forecast_results)
        self.series_counter += 1
        self.switch_to_new_series()

    def switch_to_new_series(self):
        """Switch to a new random time series."""
        self.ax.clear()  # Clear the current plot

        # Clear the user intervals for the control condition to reset the plot
        if self.condition == "control":
            self.user_intervals = {}

        # Randomly select a new series index
        self.series_index = np.random.randint(1, n_series + 1)
        self.y_noisy = simulated_df[f"Series{self.series_index}"].values

        # Plot the new time series
        self.ax.scatter(self.x, self.y_noisy, color='black', s=10, label=f"Observed Sales (Series{self.series_index})")
        self.ax.set_title(f"Time Series: Series{self.series_index}")

        # Re-initialize forecast intervals if the condition isn't "control"
        if self.condition != "control":
            self.initialize_forecasts()

        # Set plot limits and labels
        self.ax.set_xlim(0, 53)
        self.ax.set_ylim(min(self.y_noisy) - 5, max(self.y_noisy) + 5)
        self.ax.set_xlabel("Sales Period")
        self.ax.set_ylabel("Number of Sales")
        self.ax.set_yticks(np.arange(min(self.y_noisy) - 5, max(self.y_noisy) + 5, 5))
        self.ax.set_xticks(np.arange(5, 53, 5))
        self.ax.set_xticklabels([str(i) for i in range(5, 55, 5)])
        self.ax.legend()

        # Redraw the canvas
        self.fig.canvas.draw()

    def show_plot(self):
        plt.show()


# **Run the Interactive Forecasting Tool**
interactive_forecast = InteractiveForecast()
interactive_forecast.show_plot()
