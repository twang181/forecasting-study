import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Button
import pandas as pd
import csv
import mplcursors

# Read the time-series data from the CSV file generated by R
simulated_df = pd.read_csv('simulated_series_new.csv')

# Number of time series (columns) in the dataframe
n_series = simulated_df.shape[1] - 1  # Subtract 1 for the 'Time' column

forecast_df = pd.read_csv('forecast_table.csv')  # Add this line

# Experimental conditions
conditions = ["control", "80_point_interval", "95_point_interval", "80_interval", "95_interval"]

import uuid

# Class for interactive forecasting
class InteractiveForecast:
    def __init__(self):
        self.participant_id = str(uuid.uuid4())  # generates e.g. 'f58d57e4-13e2-4ae4-85fd-e3c7fa4a04b4'
        self.condition = assign_condition(self.participant_id) #randomisation

        self.fig, self.ax = plt.subplots(figsize=(8, 5))
        self.forecasts = forecast_df
        #pd.DataFrame(columns=['Series', 'Period', 'Forecast', 'Lower', 'Upper'])
        #self.forecasts = []
        self.max_forecasts = 4
        self.forecast_x_positions = np.linspace(49, 52, self.max_forecasts)

        # Assign participant to a random condition
        self.condition = np.random.choice(conditions)
        print(f"Assigned Condition: {self.condition}")

        self.cursor = None

        self.selected_series = np.random.choice(range(1, n_series + 1), size=24, replace=False)
        self.series_counter = 0 #24 series

        # Initial random series selection
        self.series_counter = 0
        self.series_index = self.selected_series[self.series_counter]

        #self.series_index = np.random.randint(1, n_series + 1)
        self.x = simulated_df['time'].values  # Time values from the 'Time' column
        self.y_noisy = simulated_df[f"series_{self.series_index}"].values  # Select one of the simulated series

        # Set the title of the plot to display which series is being shown
        self.ax.set_title(f"Time Series: Series{self.series_index}")

        # **Plot actual noisy data points (black dots)**
        self.scatter_plot = self.ax.scatter(self.x, self.y_noisy, color='black', s=10,
                                            label=f"Observed Sales (Series{self.series_index})")
        self.ax.plot(self.x, self.y_noisy, color='black', linewidth=1)  # Connecting the points

        self.ax.grid(True, linestyle="--", linewidth=0.5, color="lightgrey")

        self.set_axis_limits()

        # Adjust axis limits
        # Set plot limits and labels
        # Set plot limits and labels
        # Set plot limits and labels
        self.ax.set_xlim(0, 53)

        if hasattr(self, 'forecast_lower') and hasattr(self, 'forecast_upper'):
            # Rescale based on the forecast interval (doubling the range)
            y_min = min(self.forecast_lower)
            y_max = max(self.forecast_upper)
            margin = (y_max - y_min)  # Full range of interval
            self.ax.set_ylim(y_min - margin, y_max + margin)  # Double the interval range
        else:
            # Rescale based only on observed sales data (for control condition)
            y_min = min(self.y_noisy)
            y_max = max(self.y_noisy)
            margin = (y_max - y_min) * 0.5  # Add 20% margin for better visualization
            self.ax.set_ylim(y_min - margin, y_max + margin)

        self.ax.set_xlabel("Sales Period")
        self.ax.set_ylabel("Number of Sales")
        self.ax.set_yticks(np.arange(min(self.y_noisy) - 5, max(self.y_noisy) + 5, 5))
        self.ax.set_xticks(np.arange(5, 53, 5))
        self.ax.set_xticklabels([str(i) for i in range(5, 55, 5)])
        self.ax.legend()

        # Initialize forecast intervals if needed
        if self.condition == "control":
            self.user_intervals = {}  # Stores manually added intervals
            self.fig.canvas.mpl_connect('button_press_event', self.on_click)
        else:
            self.initialize_forecasts()

        self.selected_point = None
        self.fig.canvas.mpl_connect('pick_event', self.on_pick)
        self.fig.canvas.mpl_connect('motion_notify_event', self.on_drag)
        self.fig.canvas.mpl_connect('button_release_event', self.on_release)

        self.save_button_ax = plt.axes([0.8, 0.01, 0.1, 0.05])
        self.save_button = Button(self.save_button_ax, "Save")
        self.save_button.on_clicked(self.save_data)

        self.cursor = mplcursors.cursor(self.scatter_plot, hover=True)
        self.cursor.connect("add", lambda sel: sel.annotation.set_text(f"({sel.target[0]:.0f}, {sel.target[1]:.2f})"))

    def initialize_forecasts(self):
        """Initialize bars + draggable handles for forecast intervals."""
        confidence_level = "95" if "95" in self.condition else "80"
        lower_col = f"lower_{confidence_level}"
        upper_col = f"upper_{confidence_level}"

        self.bars = []
        self.lower_handles = []
        self.upper_handles = []

        bar_width = 0.5

        # Enable interactive hover labels for forecasted points
        mplcursors.cursor(self.ax.patches, hover=True).connect(
            "add", lambda sel: sel.annotation.set_text(f"({int(sel.target[0])}, {sel.target[1]:.2f})")
        )

        self.forecast_lower = [] #scaling y-axis
        self.forecast_upper = []

        for i, x_pos in enumerate(self.forecast_x_positions):
            # Filter the correct row in the forecast dataframe
            row = self.forecasts[
                (self.forecasts['Series'] == self.series_index) &
                (self.forecasts['time'] == x_pos)
                ]

            # Get lower and upper interval bounds from the CSV
            if not row.empty:
                lower = row[lower_col].values[0]
                upper = row[upper_col].values[0]

            else:
                # Default/fallback if no data found (shouldnâ€™t happen ideally)
                lower = 0
                upper = 0
            self.forecast_lower.append(lower)
            self.forecast_upper.append(upper)

            height = upper - lower

            # Create the bar
            bar = self.ax.bar(x_pos, height, bottom=lower, width=bar_width, color='skyblue', edgecolor=None)[0]
            self.bars.append((x_pos, bar))

            # Keep the handles but make them invisible
            lower_handle, = self.ax.plot(x_pos, lower, marker='o', color='red', markersize=8, picker=True)
            lower_handle.set_alpha(0)
            lower_handle.set_pickradius(5)

            upper_handle, = self.ax.plot(x_pos, upper, marker='o', color='green', markersize=8, picker=True)
            upper_handle.set_alpha(0)
            upper_handle.set_pickradius(5)

            self.lower_handles.append((x_pos, lower_handle))
            self.upper_handles.append((x_pos, upper_handle))

            if "point" in self.condition:
                point_forecast = np.mean([lower, upper])
                self.ax.plot(x_pos, point_forecast, 'bo', markersize=6, label="Point Forecast" if i == 0 else "")


    def set_axis_limits(self):
        y_min, y_max = np.min(self.y_noisy), np.max(self.y_noisy)
        interval_min = np.min(self.forecast_lower) if hasattr(self, 'forecast_lower') else y_min
        interval_max = np.max(self.forecast_upper) if hasattr(self, 'forecast_upper') else y_max
        self.ax.set_ylim(interval_min - (interval_max - interval_min), interval_max + (interval_max - interval_min))
        self.ax.set_xlim(0, 53)
        self.ax.set_xlabel("Sales Period")
        self.ax.set_ylabel("Number of Sales")

    def calculate_prediction_interval(self, y, confidence_level=0.95):
        """Calculate prediction interval based on confidence level."""
        z_value = 1.96 if confidence_level == 0.95 else 1.28  # Approximate z-scores
        residuals = y - np.mean(y)
        std_dev = np.std(residuals)
        margin_of_error = z_value * std_dev
        y_upper = y + margin_of_error
        y_lower = y - margin_of_error
        return y_lower, y_upper

    def on_click(self, event):
        if self.condition != "control" or event.inaxes != self.ax:
            return

        x_pos = round(event.xdata)
        y_pos = event.ydata

        # Only allow clicks in forecast periods
        if x_pos not in self.forecast_x_positions:
            return

        # Clip y_pos to stay within axis limits
        ylim = self.ax.get_ylim()
        y_pos = np.clip(y_pos, ylim[0], ylim[1])

        lower, upper, bar = self.user_intervals.get(x_pos, [None, None, None])

        if lower is None:
            lower = y_pos
        elif upper is None:
            upper = y_pos
        else:
            # Overwrite the closer one for fine-tuning
            if abs(y_pos - lower) < abs(y_pos - upper):
                lower = y_pos
            else:
                upper = y_pos

        # Ensure lower < upper
        if lower is not None and upper is not None and lower > upper:
            lower, upper = upper, lower

        self.user_intervals[x_pos] = [lower, upper, bar]

        self.add_bar(x_pos)

    def add_bar(self, x_pos):
        lower, upper, old_bar = self.user_intervals[x_pos]

        # Only add bar if both bounds exist
        if lower is None or upper is None:
            return

        # Remove old bar if it exists
        if old_bar:
            old_bar.remove()

        bar = self.ax.bar(x_pos, upper - lower, bottom=lower, width=0.5, color='skyblue', edgecolor=None, alpha=0.4)[
            0]
        self.user_intervals[x_pos][2] = bar
        self.fig.canvas.draw()

    def update_manual_intervals(self):
        """Ensures each x-position has only one lower and one upper bound, replacing old ones before adding new ones."""

        # Step 1: Remove any old points for the clicked position
        for line in self.ax.get_lines()[:]:  # Loop over existing lines in the plot
            x_pos = line.get_xdata()[0]
            label = line.get_label()

            # Remove existing lower and upper bound points
            if label in ["Lower Bound", "Upper Bound"]:
                line.remove()

        # Step 2: Add the new points for the clicked position (one red for lower, one green for upper)
        for x_pos, (lower, upper, _) in self.user_intervals.items():
            if lower is not None and upper is not None:
                if lower > upper:
                    self.ax.plot(x_pos, lower, 'go', markersize=6, label="Lower Bound")
                    self.ax.plot(x_pos, upper, 'ro', markersize=6, label="Upper Bound")
                else:
                    self.ax.plot(x_pos, upper, 'go', markersize=6, label="Upper Bound")
                    self.ax.plot(x_pos, lower, 'ro', markersize=6, label="Lower Bound")
            elif lower is not None:
                self.ax.plot(x_pos, lower, 'ro', markersize=6, label="Lower Bound")
            elif upper is not None:
                self.ax.plot(x_pos, upper, 'go', markersize=6, label="Upper Bound")

        self.fig.canvas.draw()

    def on_pick(self, event):
        for x_pos, handle in self.lower_handles:
            if event.artist == handle:
                self.selected_point = (x_pos, "lower", handle)
                return
        for x_pos, handle in self.upper_handles:
            if event.artist == handle:
                self.selected_point = (x_pos, "upper", handle)
                return

    def on_drag(self, event):
        if self.selected_point and event.inaxes == self.ax:
            x_pos, bound_type, handle = self.selected_point

            # Drag handle
            ylim = self.ax.get_ylim()
            ydata = np.clip(event.ydata, ylim[0], ylim[1])
            handle.set_ydata([ydata])

            # Find the corresponding bar
            for idx, (bar_x, bar) in enumerate(self.bars):
                if bar_x == x_pos:
                    lower_y = self.lower_handles[idx][1].get_ydata()[0]
                    upper_y = self.upper_handles[idx][1].get_ydata()[0]

                    # Ensure lower < upper
                    if lower_y > upper_y:
                        lower_y, upper_y = upper_y, lower_y
                        self.lower_handles[idx][1].set_ydata([lower_y])
                        self.upper_handles[idx][1].set_ydata([upper_y])

                    # Update bar's position and height
                    bar.set_y(lower_y)
                    bar.set_height(upper_y - lower_y)
                    break

            self.fig.canvas.draw()

    def on_release(self, event):
        self.selected_point = None

    def save_data(self, event):
        forecast_results = []

        if self.condition == "control":
            for x_pos, (lower, upper, _) in self.user_intervals.items():
                print(f"Processing x_pos={x_pos}, lower={lower}, upper={upper}")  # Extra debug

            for x_pos, (lower, upper, _) in self.user_intervals.items():
                forecast_results.append((x_pos, lower, upper))
        else:
            for x_pos, bar in self.bars:
                lower = bar.get_y()
                upper = bar.get_y() + bar.get_height()
                forecast_results.append((x_pos, lower, upper))

        with open('forecast_results.csv', mode='a', newline='') as file:
            writer = csv.writer(file)
            if file.tell() == 0:
                writer.writerow(["Participant_ID", "Series", "Period", "Lower", "Upper", "Condition"])
            for period, lower, upper in forecast_results:
                #writer.writerow([*result, self.condition])
                writer.writerow([self.participant_id, self.series_index, period, lower, upper, self.condition])

        print("Saved Forecasts:", forecast_results)
        self.switch_to_new_series()

        #self.series_counter += 1
       # self.switch_to_new_series()

    def switch_to_new_series(self):
        """Switch to the next series in the participantâ€™s pre-selected list."""
        if self.series_counter >= len(self.selected_series):
            print("All 24 series completed.")
            plt.close(self.fig)  # or show a completion message
            return

        self.series_index = self.selected_series[self.series_counter]
        self.series_counter += 1

        self.ax.clear()

        if self.cursor is not None:
            self.cursor.remove()
            self.cursor = None

        if self.condition == "control":
            self.user_intervals = {}

        self.y_noisy = simulated_df[f"series_{self.series_index}"].values

        scatter_plot = self.ax.scatter(self.x, self.y_noisy, color='black', s=10,
                                       label=f"Observed Sales (Series{self.series_index})")
        self.ax.plot(self.x, self.y_noisy, color='black', linewidth=1)
        self.ax.set_title(f"Time Series: Series{self.series_index}")
        self.ax.grid(True, linestyle="--", linewidth=0.5, color="lightgrey")

        if self.condition != "control":
            self.initialize_forecasts()

        y_min = min(self.y_noisy)
        y_max = max(self.y_noisy)
        if hasattr(self, 'forecast_lower') and hasattr(self, 'forecast_upper'):
            y_min = min(y_min, min(self.forecast_lower))
            y_max = max(y_max, max(self.forecast_upper))
        margin = (y_max - y_min) * 0.2
        self.ax.set_ylim(y_min - margin, y_max + margin)

        self.ax.set_xlim(0, 53)
        self.ax.set_xlabel("Sales Period")
        self.ax.set_ylabel("Number of Sales")
        self.ax.set_yticks(np.arange(y_min - 5, y_max + 5, 5))
        self.ax.set_xticks(np.arange(5, 53, 5))
        self.ax.set_xticklabels([str(i) for i in range(5, 55, 5)])
        self.ax.legend()

        self.cursor = mplcursors.cursor(scatter_plot, hover=True)
        self.cursor.connect("add", lambda sel: sel.annotation.set_text(f"({sel.target[0]:.0f}, {sel.target[1]:.2f})"))

        self.fig.canvas.draw_idle()

    def show_plot(self):
        plt.show()

    print("Total available series:", n_series)

def assign_condition(participant_id):
    try:
        df = pd.read_csv("participant_assignments.csv")
    except FileNotFoundError:
        df = pd.DataFrame(columns=["participant_id", "condition"])

    counts = df["condition"].value_counts().reindex(conditions, fill_value=0)
    total = counts.sum() + 1

    probs = 1 - (counts / total)
    probs = probs / probs.sum()

    condition = np.random.choice(conditions, p=probs)

    new_row = pd.DataFrame([{"participant_id": participant_id, "condition": condition}])
    df = pd.concat([df, new_row], ignore_index=True)
    df.to_csv("participant_assignments.csv", index=False)

    return condition


# **Run the Interactive Forecasting Tool**
interactive_forecast = InteractiveForecast()
interactive_forecast.show_plot()
